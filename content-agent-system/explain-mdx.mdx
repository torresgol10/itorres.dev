# MDX: Deja de escribir texto, empieza a programar contenido üöÄ

Markdown se te ha quedado peque√±o. Es la verdad. Para un README b√°sico est√° bien, pero si est√°s construyendo documentaci√≥n t√©cnica, un blog de ingenier√≠a o un sistema de dise√±o, el HTML est√°tico es una c√°rcel. **Es hora de que tu contenido sea software.** üî•

**MDX** no es solo "Markdown con superpoderes"; es un cambio de paradigma donde tus archivos `.mdx` se compilan como componentes de React (o Vue/Svelte). Ya no pegas capturas de pantalla; insertas el componente real. ‚öõÔ∏è

---

### El salto: De est√°tico a interactivo

En el flujo tradicional, el Markdown es texto muerto. En MDX, tienes acceso total al ecosistema de tu framework. ¬øQuieres un playground interactivo en medio de un post? Solo imp√≥rtalo.

```mdx
import { LiveCode } from '@/components/Editor'
import { FeatureChart } from '@/components/Charts'

# Optimizando el Event Loop ‚ö°Ô∏è

Antes de profundizar, mira c√≥mo se comporta la cola de tareas en tiempo real:

<LiveCode snippet="setTimeout(() => console.log('Macro'), 0)" />

<FeatureChart data={performanceData} />
```

### Matiz Senior: El Runtime importa (y mucho) üß†

Aqu√≠ es donde muchos juniors se pierden. No es lo mismo renderizar MDX en tiempo de compilaci√≥n que en tiempo de ejecuci√≥n.

1.  **`next-mdx-remote`:** Es el est√°ndar actual para **React Server Components (RSC)**. No necesita bundlers pesados en el cliente y es ideal si traes el contenido desde un CMS o base de datos. Mantiene el JS al m√≠nimo. üìâ
2.  **`mdx-bundler`:** Si necesitas resolver imports complejos de otros archivos dentro de tus propios archivos MDX, esta es tu herramienta. Es m√°s pesado pero m√°s flexible.
3.  **Seguridad:** MDX ejecuta c√≥digo. **Nunca** renderices MDX que provenga de inputs de usuarios no confiables sin un proceso de sanitizaci√≥n riguroso.

### Component Mapping: El "Hack" de Productividad

No pierdas tiempo a√±adiendo clases de Tailwind a cada p√°rrafo. Usa el `provider` para mapear elementos est√°ndar a tus componentes de dise√±o:

```tsx
// components/mdx-layout.tsx
const components = {
  h1: (props) => <h1 className="text-4xl font-extrabold tracking-tight" {...props} />,
  a: (props) => <CustomLink className="text-primary underline" {...props} />,
  pre: CodeSnippet, // Syntax highlighting con Shiki o Prism
}

export function MDXRemoteWrapper({ source }) {
  return <MDXRemote {...source} components={components} />
}
```

### MDX en la era de los Server Components (Next.js 14/15) üèóÔ∏è

Hoy, la mejor forma de usar MDX es aprovechando **RSC**. Al usar el paquete `@next/mdx`, el contenido se procesa en el servidor. 

**Resultado:** El usuario recibe HTML puro para el texto y solo descarga el JavaScript necesario para los componentes interactivos que hayas incluido. **Zero-bundle-size por defecto.** ‚ö°Ô∏è

### Buenas Pr√°cticas vs. Errores de Novato

*   **‚ùå Error:** Definir l√≥gica de negocio pesada o `useEffects` gigantes dentro del archivo `.mdx`.
*   **‚úÖ Pr√°ctica:** Mant√©n el MDX limpio. Si la l√≥gica supera las 5 l√≠neas, mu√©vela a un componente externo y √∫salo como una "caja negra".
*   **‚úÖ Pr√°ctica:** Usa **Metadata (Frontmatter)** para el SEO y la gesti√≥n de fechas, pero tipado con herramientas como `contentlayer` o `velite` para evitar errores en tiempo de ejecuci√≥n.

### Conclusi√≥n

Markdown te dio la estructura; MDX te da el control total de la UI. Si tu documentaci√≥n no permite al usuario interactuar con el c√≥digo, est√°s enviando a tus desarrolladores de vuelta a los a√±os 90. **Programa tu contenido.** üöÄ