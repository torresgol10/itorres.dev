 ---
title: 'Control moderno del scroll en CSS: Solucionando el problema del header fijo'
excerpt: 'Domina las propiedades scroll-* para crear navegaciÃ³n fluida sin JavaScript y corrige el clÃ¡sico error donde los headers fijos ocultan el contenido destino al usar enlaces de ancla.'
categories: ['CSS', 'UX']
date: '2026-01-28'

author:
  name: "IvÃ¡n Torres"
  role: "Software Developer"
---

# Control moderno del scroll en CSS: Solucionando el problema del header fijo

Â¿Te ha pasado que al hacer click en un enlace de ancla, el tÃ­tulo queda escondido bajo tu header fijo? ğŸ˜« Es el error de UX clÃ¡sico que seguimos viendo en producciÃ³n.

OlvÃ­date de jQuery y esos hacks con `padding-top` gigante. El scroll nativo en CSS ya estÃ¡ aquÃ­ y es brutal ğŸš€. Vamos a ver cÃ³mo controlar la navegaciÃ³n, el desbordamiento y esa experiencia tÃ¡ctil directamente desde CSS, sin librerÃ­as externas.

## El problema real: Cuando el menÃº fijo tapa todo ğŸ”§

Tenemos un patrÃ³n sÃºper comÃºn: navegaciÃ³n fija (`position: sticky` o `fixed`) de 60-80px combinada con enlaces internos `<a href="#seccion">`. 

Pero aquÃ­ viene el dolor: al hacer clic, el navegador lleva el elemento destino exactamente al borde superior del viewport... Â¡y zas! Tu header lo tapa completamente. El usuario no ve ni el tÃ­tulo ni el contenido relevante.

Las soluciones viejas â€”ese `padding-top` compensatorio de 100px con `margin-top` negativo, o peor, JavaScript calculando offsetsâ€” son deuda tÃ©cnica pura. Rompen el layout, causan shifts y son un mantenimiento horrible.

## La familia scroll-*: Tus nuevas superpoderes ğŸ’ª

### 1. Scroll Behavior ğŸŒŠ
Â¿Recuerdas cuando necesitÃ¡bamos jQuery solo para una animaciÃ³n suave? Es historia antigua.

Simplemente aÃ±ade esto a tu `html` y listo:

```css
html {
  scroll-behavior: smooth;
}
```

**âš ï¸ Nota de accesibilidad:** Respeta `prefers-reduced-motion`. Algunos usuarios sufren mareos con animaciones:

```css
@media (prefers-reduced-motion: no-preference) {
  html {
    scroll-behavior: smooth;
  }
}
```

### 2. Overscroll Behavior ğŸš«
Â¿Odias cuando haces scroll en un modal, llegas al final, y de repente se mueve la pÃ¡gina de fondo? Eso es "scroll chaining" y es horrible.

Le decimos al navegador que se contenga:

```css
.modal {
  overflow-y: auto;
  overscroll-behavior: contain; /* El scroll se queda aquÃ­, punto */
}
```

### 3. Scroll Padding y Scroll Margin ğŸ¯
AquÃ­ estÃ¡ la joya de la corona. La soluciÃ³n nativa al problema del header fijo sin hacks ni JavaScript.

## ImplementaciÃ³n paso a paso ğŸ› ï¸

### SoluciÃ³n global con scroll-padding
Aplica esto al contenedor de scroll (tu `html` o `body`). Le decimos al navegador: *"Oye, el borde superior real estÃ¡ 80px mÃ¡s abajo"*:

```css
html {
  scroll-behavior: smooth;
  scroll-padding-top: 80px; /* Altura del header + un poco de aire */
}
```

AsÃ­ de simple. Cuando alguien haga clic en un ancla, el navegador respeta esa zona y deja espacio para tu header.

### SoluciÃ³n local con scroll-margin
Â¿Necesitas granularidad por componente? Aplica el margen directamente al elemento destino:

```css
[id] {
  scroll-margin-top: 80px;
}

/* O especÃ­ficamente en headings */
h2, h3 {
  scroll-margin-top: 6rem;
}
```

**Â¿CuÃ¡ndo usar cada una?**
- Usa `scroll-padding` en el contenedor para aplicaciones globales (SPAs, documentaciÃ³n).
- Usa `scroll-margin` en elementos especÃ­ficos cuando diferentes secciones necesitan offsets distintos.

## Mejores prÃ¡cticas vs errores comunes âš ï¸

**âŒ Error:** Aplicar `padding-top` enorme a las secciones y compensar con `margin-top` negativo. Rompes el flujo del documento y fastidias a los lectores de pantalla.

**âœ… Correcto:** Usar `scroll-padding` o `scroll-margin`. No alteran el layout visual, solo el cÃ¡lculo del scroll. CSS puro, sin trucos.

**âŒ Error:** Forzar `scroll-behavior: smooth` sin consultar preferencias de movimiento reducido.

**âœ… Correcto:** Implementar la media query `prefers-reduced-motion`. Es accesibilidad real, no solo checkboxes.

**ğŸŒ Compatibilidad:** Todas estas propiedades tienen soporte completo en Chrome, Firefox, Safari y Edge modernos. Sin polyfills, sin excusas.

## ConclusiÃ³n ğŸ¯

Deja atrÃ¡s los hacks de JavaScript para corregir el desplazamiento. Con `scroll-padding` y `scroll-margin` solucionas el problema del header fijo en dos lÃ­neas de CSS. 

CombÃ­nalas con `scroll-behavior` y `overscroll-behavior` y tienes control total sobre la navegaciÃ³n nativa: experiencias fluidas, accesibles y mantenibles. 

Tu cÃ³digo (y tus usuarios) te lo agradecerÃ¡n.